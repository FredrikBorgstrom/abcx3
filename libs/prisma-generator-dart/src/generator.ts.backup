import { DMMF, generatorHandler, GeneratorOptions } from '@prisma/generator-helper';
import { convertBooleanStrings, convertEnvStrings, copyCommonSourceFiles, initEnv, outputToConsoleAsync, StringFns, writeFileSafelyAsync } from '@shared';
import { exec } from 'child_process';
import path from 'path';
import { GENERATOR_NAME } from './constants';
import { DartGeneratorSettings } from './dart_settings.interface';
import { DartGenerator } from './generators/dart.generator';
import { DartStoreGenerator } from './generators/dart_store.generator';
import { EndpointGenerator } from './generators/endpoint.generator';
import { generateDartEnum } from './generators/enum.generators';
import { dartStoreLibrary } from './stubs/stores_library.stub';

const { version } = require('../package.json');

const defaultOptions: DartGeneratorSettings = {
    AutoGeneratedWarningText: '//***  AUTO-GENERATED FILE - DO NOT MODIFY ***// ',
    active: true,
    dryRun: false,
    schemaPath: '',
    EnumPath: 'enums',
    FormatWithDart: true,
    MakeAllPropsOptional: true,
    UpdateStoresDefaultRecursiveDepth: 4,
    // ModelsImplementBaseClass: true,
    // CommonSourceDirectory: 'common',
    // ModelsBaseClassFileName: 'prisma_model.dart',
    GenerateEndpoints: false,
    BackendPath: 'src',
    EndpointsOutputPath: 'gen_backend_routes.dart',
    outputSetupForDevtools: false,
};

generatorHandler({
    onManifest() {
        console.log(`${GENERATOR_NAME}:Registered`);
        initEnv();
        return {
            version,
            defaultOutput: '../generated',
            prettyName: GENERATOR_NAME,
        }
    },
    onGenerate: async (options: GeneratorOptions) => {
        const configOverwrites = {
            schemaPath: options.schemaPath,
        };

        const optionsWithEnvSettings = convertEnvStrings(options.generator.config);
        const optionsWithBooleanSettings = convertBooleanStrings(optionsWithEnvSettings);
        const settings: DartGeneratorSettings = {
            ...defaultOptions,
            ...optionsWithBooleanSettings,
            ...configOverwrites,
        };

        if (settings.active === true) {
            const mainGenerator = new MainGenerator(options, settings);
            await mainGenerator.generateFiles();
        } else {
            console.log('dart generator is not active');
        }
    }
})

class MainGenerator {

    //private dartFiles: string[] = [];
    private modelFiles: Record<string, string> = {};
    private dartStoreFiles: Record<string, string> = {};

    writeFile: (path: string, content: string) => Promise<void>;
    outputPath: string;

    constructor(private options: GeneratorOptions, private settings: DartGeneratorSettings) {
        this.writeFile = settings.dryRun ? outputToConsoleAsync : writeFileSafelyAsync;
        this.outputPath = this.options.generator.output?.value as string;
    }

    async generateFiles(options = this.options, settings = this.settings) {

        copyCommonSourceFiles('dart_source', this.outputPath);

        // Debug: Log DMMF structure to understand Prisma 7 changes
        console.log('DMMF Debug Info:');
        console.log('  options keys:', Object.keys(options || {}));
        const optionsAny = options as any;
        if (optionsAny?.datamodel) {
            const isArray = Array.isArray(optionsAny.datamodel);
            const isArrayLike = !isArray && optionsAny.datamodel.length !== undefined;
            console.log('  options.datamodel is array:', isArray);
            console.log('  options.datamodel is array-like:', isArrayLike);
            console.log('  options.datamodel length:', optionsAny.datamodel.length ?? 'undefined');
            
            // Check first few items to understand structure
            const firstItem = optionsAny.datamodel[0];
            if (firstItem) {
                console.log('  options.datamodel[0] keys:', Object.keys(firstItem));
                console.log('  options.datamodel[0] type:', firstItem.type ?? firstItem.kind ?? 'undefined');
                console.log('  options.datamodel[0] name:', firstItem.name ?? 'undefined');
            }
            
            // Check if it has models/enums properties (object case)
            if (!isArray && !isArrayLike) {
                console.log('  options.datamodel keys:', Object.keys(optionsAny.datamodel || {}));
                console.log('  options.datamodel.models length:', optionsAny.datamodel?.models?.length ?? 'undefined');
                console.log('  options.datamodel.enums length:', optionsAny.datamodel?.enums?.length ?? 'undefined');
            }
        } else {
            console.log('  options.datamodel: not present');
        }
        console.log('  options.dmmf keys:', Object.keys(options.dmmf || {}));
        console.log('  options.dmmf.datamodel keys:', Object.keys(options.dmmf?.datamodel || {}));
        console.log('  options.dmmf.datamodel.models length:', options.dmmf?.datamodel?.models?.length ?? 'undefined');
        console.log('  options.dmmf.datamodel.enums length:', options.dmmf?.datamodel?.enums?.length ?? 'undefined');
        const dmmfAny = options.dmmf as any;
        if (dmmfAny?.schema) {
            console.log('  options.dmmf.schema keys:', Object.keys(dmmfAny.schema || {}));
            console.log('  options.dmmf.schema.datamodel keys:', Object.keys(dmmfAny.schema?.datamodel || {}));
        }
        if (optionsAny?.schema) {
            console.log('  options.schema exists:', typeof optionsAny.schema);
        }
        
        // Try to get models and enums - handle both Prisma 6 and 7 structures
        const models = this.getModels(options);
        const enums = this.getEnums(options);

        for (const model of models) {
            console.log(`Processing Model ${model.name}`);
            await this.generateDartModelFile(model);
            await this.generateDartStoreFile(model);
        }

        for (const tEnum of enums) {
            console.log(`Processing Enum ${tEnum.name}`);
            await this.generateDartEnumFile(tEnum);
        }



        await this.createDartLibraryFile(options);
        await this.generateStoreLibraryFile();

        // Optionally emit a helper to wire stores into DevTools
        if (this.settings.outputSetupForDevtools || (this as any).settings.OutputSetupForDevtools) {
            await this.generateDevtoolsSetupFile();
        }

        // Generate endpoints if enabled
        if (this.settings.GenerateEndpoints || this.settings.generateEndpoints) {
            await this.generateEndpoints();
        }

        if (this.settings.FormatWithDart) {
            const outputPath = options.generator.output?.value;
            exec(`dart format "${outputPath}"`, (error, stdout, stderr) => {
                if (error) {
                    console.log('dart format couldn\'t run. Make sure you have Dart installed properly by going to https://dart.dev/get-dart');
                    console.log(`error: ${error.message}`);
                    return;
                }
                if (stderr) {
                    console.log(`stderr: ${stderr}`);
                    return;
                }
                console.log(`stdout: ${stdout}`);
            });
        }



        console.log('Done!');
    }

    /*  async writeModelBaseFile() {
         const fileName = this.settings.ModelsBaseClassFileName;
         const filePath = path.join(this.outputPath, this.settings.CommonSourceDirectory, fileName);
         const code = dartInterfacesAndModelFunctionsStub;
         await this.writeFile(filePath, code);
     } */

    /* async copyCommonSourceFiles(dirName: string, destPath: string) {
        console.log('Copying dart source files');
        console.log('__dirname', __dirname);
        const sourcePath = path.join(__dirname, dirName);
        this.copyDirectoryAndContent(sourcePath, destPath;
    } */

        /* const common_src = path.join(sourcePath, 'common');
        const common_dest =  path.join(this.outputPath, 'common');
        await this.copyDirectoryAndContent(common_src, common_dest);

        const stores_common_src = path.join(sourcePath, 'stores_common');
        const stores_common_dest =  path.join(this.outputPath, 'stores_common');
        await this.copyDirectoryAndContent(stores_common_src, stores_common_dest); */
    

    /* async copyDirectoryAndContent(source: string, target: string) {
        
        return await fs.cp(source, target, {recursive: true}, (err) => {
            if (err) {
                console.log('Error copying dart source files', err);
                return;
            }
            console.log(`${source} was copied to ${target}`);
        });
    } */
    /* copyDirectoryAndContent(source: string, target: string) {
        fs.cpSync(source, target, { recursive: true, force: true });
    } */


    async generateDartEnumFile(tEnum: DMMF.DatamodelEnum) {
        let content = generateDartEnum(tEnum, this.settings.AutoGeneratedWarningText);
        const fileName = `${StringFns.snakeCase(tEnum.name)}.dart`;
        const filePath = path.join(this.outputPath, 'models', fileName);
        console.log(` > Generating enum for Model ${tEnum.name}`);
        await this.writeFile(filePath, content);
        this.modelFiles[tEnum.name] = 'models/' + fileName;
    }

    private getModels(options: GeneratorOptions): DMMF.Model[] {
        const optionsAny = options as any;
        const dmmfAny = options.dmmf as any;
        
        // Prisma 7: options.datamodel might be an array or array-like object of schema items
        if (optionsAny?.datamodel) {
            const datamodel = optionsAny.datamodel;
            const isArray = Array.isArray(datamodel);
            const isArrayLike = !isArray && datamodel.length !== undefined;
            
            if (isArray || isArrayLike) {
                // Convert array-like to array if needed
                const items = isArray ? datamodel : Array.from(datamodel);
                const models = items.filter((item: any) => {
                    // Check various possible properties that indicate a model
                    return item?.type === 'model' || 
                           item?.kind === 'model' ||
                           (item?.name && item?.fields && !item?.values); // model has fields, enum has values
                });
                if (models.length > 0) {
                    console.log(`Found ${models.length} models in options.datamodel ${isArray ? 'array' : 'array-like object'}`);
                    return models;
                }
            }
        }
        
        // Try options.datamodel.models (if it's an object with models property)
        if (optionsAny?.datamodel?.models && Array.isArray(optionsAny.datamodel.models) && optionsAny.datamodel.models.length > 0) {
            console.log(`Found ${optionsAny.datamodel.models.length} models in options.datamodel.models`);
            return optionsAny.datamodel.models;
        }
        
        // Try standard Prisma 6 path (even if empty, log it for debugging)
        if (options.dmmf?.datamodel?.models && Array.isArray(options.dmmf.datamodel.models)) {
            if (options.dmmf.datamodel.models.length > 0) {
                console.log(`Found ${options.dmmf.datamodel.models.length} models in options.dmmf.datamodel.models`);
                return options.dmmf.datamodel.models;
            } else {
                console.warn('options.dmmf.datamodel.models exists but is empty (length 0). This may indicate a Prisma version mismatch.');
            }
        }
        
        // Try options.schema.datamodel.models (Prisma 7 might have schema at options level)
        if (optionsAny?.schema?.datamodel?.models && Array.isArray(optionsAny.schema.datamodel.models) && optionsAny.schema.datamodel.models.length > 0) {
            console.log('Found models in options.schema.datamodel.models');
            return optionsAny.schema.datamodel.models;
        }
        
        // Try dmmf.schema.datamodel.models
        if (dmmfAny?.schema?.datamodel?.models && Array.isArray(dmmfAny.schema.datamodel.models) && dmmfAny.schema.datamodel.models.length > 0) {
            console.log('Found models in options.dmmf.schema.datamodel.models');
            return dmmfAny.schema.datamodel.models;
        }
        
        // Try direct access on dmmf
        if (dmmfAny?.models && Array.isArray(dmmfAny.models) && dmmfAny.models.length > 0) {
            console.log('Found models in options.dmmf.models');
            return dmmfAny.models;
        }
        
        // Try direct access on options
        if (optionsAny?.models && Array.isArray(optionsAny.models) && optionsAny.models.length > 0) {
            console.log('Found models in options.models');
            return optionsAny.models;
        }
        
        console.warn('Warning: Could not find models in DMMF structure. Available keys:', Object.keys(options.dmmf || {}));
        console.warn('  options.datamodel keys:', optionsAny?.datamodel ? Object.keys(optionsAny.datamodel) : 'not present');
        return [];
    }

    private getEnums(options: GeneratorOptions): DMMF.DatamodelEnum[] {
        const optionsAny = options as any;
        const dmmfAny = options.dmmf as any;
        
        // Prisma 7: options.datamodel might be an array or array-like object of schema items
        if (optionsAny?.datamodel) {
            const datamodel = optionsAny.datamodel;
            const isArray = Array.isArray(datamodel);
            const isArrayLike = !isArray && datamodel.length !== undefined;
            
            if (isArray || isArrayLike) {
                // Convert array-like to array if needed
                const items = isArray ? datamodel : Array.from(datamodel);
                const enums = items.filter((item: any) => {
                    // Check various possible properties that indicate an enum
                    return item?.type === 'enum' || 
                           item?.kind === 'enum' ||
                           (item?.name && item?.values && !item?.fields); // enum has values, model has fields
                });
                if (enums.length > 0) {
                    console.log(`Found ${enums.length} enums in options.datamodel ${isArray ? 'array' : 'array-like object'}`);
                    return enums;
                }
            }
        }
        
        // Try options.datamodel.enums (if it's an object with enums property)
        if (optionsAny?.datamodel?.enums && Array.isArray(optionsAny.datamodel.enums) && optionsAny.datamodel.enums.length > 0) {
            console.log(`Found ${optionsAny.datamodel.enums.length} enums in options.datamodel.enums`);
            return optionsAny.datamodel.enums;
        }
        
        // Try standard Prisma 6 path (even if empty, log it for debugging)
        if (options.dmmf?.datamodel?.enums && Array.isArray(options.dmmf.datamodel.enums)) {
            if (options.dmmf.datamodel.enums.length > 0) {
                console.log(`Found ${options.dmmf.datamodel.enums.length} enums in options.dmmf.datamodel.enums`);
                return options.dmmf.datamodel.enums;
            } else {
                console.warn('options.dmmf.datamodel.enums exists but is empty (length 0). This may indicate a Prisma version mismatch.');
            }
        }
        
        // Try options.schema.datamodel.enums (Prisma 7 might have schema at options level)
        if (optionsAny?.schema?.datamodel?.enums && Array.isArray(optionsAny.schema.datamodel.enums) && optionsAny.schema.datamodel.enums.length > 0) {
            console.log('Found enums in options.schema.datamodel.enums');
            return optionsAny.schema.datamodel.enums;
        }
        
        // Try dmmf.schema.datamodel.enums
        if (dmmfAny?.schema?.datamodel?.enums && Array.isArray(dmmfAny.schema.datamodel.enums) && dmmfAny.schema.datamodel.enums.length > 0) {
            console.log('Found enums in options.dmmf.schema.datamodel.enums');
            return dmmfAny.schema.datamodel.enums;
        }
        
        // Try direct access on dmmf
        if (dmmfAny?.enums && Array.isArray(dmmfAny.enums) && dmmfAny.enums.length > 0) {
            console.log('Found enums in options.dmmf.enums');
            return dmmfAny.enums;
        }
        
        // Try direct access on options
        if (optionsAny?.enums && Array.isArray(optionsAny.enums) && optionsAny.enums.length > 0) {
            console.log('Found enums in options.enums');
            return optionsAny.enums;
        }
        
        console.warn('Warning: Could not find enums in DMMF structure. Available keys:', Object.keys(options.dmmf || {}));
        console.warn('  options.datamodel keys:', optionsAny?.datamodel ? Object.keys(optionsAny.datamodel) : 'not present');
        return [];
    }

    async createDartLibraryFile(options: GeneratorOptions = this.options) {
        // If modelFiles is empty, rebuild it from the options as a fallback (for Prisma 7 compatibility)
        if (Object.keys(this.modelFiles).length === 0) {
            console.warn('Warning: modelFiles is empty. Rebuilding from options...');
            const models = this.getModels(options);
            const enums = this.getEnums(options);
            
            for (const model of models) {
                const fileName = `${StringFns.snakeCase(model.name)}.dart`;
                this.modelFiles[model.name] = 'models/' + fileName;
            }
            for (const tEnum of enums) {
                const fileName = `${StringFns.snakeCase(tEnum.name)}.dart`;
                this.modelFiles[tEnum.name] = 'models/' + fileName;
            }
        }
        // Ensure modelFiles is properly populated - use Object.keys for safety
        const modelFileKeys = Object.keys(this.modelFiles);
        if (modelFileKeys.length === 0) {
            console.warn('Warning: No model files found in modelFiles object after rebuilding. This may indicate an issue with Prisma version compatibility.');
        }
        let content = modelFileKeys.reduce((acc, key) => acc + `export '${this.modelFiles[key]}';\n`, "");
        // let content = this.dartFiles.reduce((acc, val) => acc + `export '${val}';\n`, "");
        const filePath = path.join(
            this.outputPath,
            `models_library.dart`
        );
        await this.writeFile(filePath, content);
    }

    async generateDartModelFile(model: DMMF.Model) {
        const dartGenerator = new DartGenerator(this.settings, model);
        const dartContent = dartGenerator.generateContent();
        const fileName = `${StringFns.snakeCase(model.name)}.dart`;
        const filePath = path.join(
            this.outputPath,
            'models',
            fileName,
        );
        this.modelFiles[model.name] = 'models/' + fileName;
        console.log(` > Generating Dart class for Model ${model.name}`);
        await this.writeFile(filePath, dartContent);
    }

    async generateDartStoreFile(model: DMMF.Model) {

        const dartStoreGenerator = new DartStoreGenerator(this.settings, model, this.options);
        const dartContent = dartStoreGenerator.generateContent();
        const fileName = `${StringFns.snakeCase(model.name)}_store.dart`;
        const filePath = path.join(
            this.outputPath,
            'stores',
            fileName,
        );
        this.dartStoreFiles[model.name] = 'stores/' + fileName;
        console.log(` > Generating Dart Store class for Model ${model.name}`);
        await this.writeFile(filePath, dartContent);
    }

    async generateStoreLibraryFile() {
        let content = dartStoreLibrary;
        let partsContent = Object.keys(this.dartStoreFiles).reduce((acc, key) => acc + `part '${this.dartStoreFiles[key]}';\n`, "");
        content = content.replace(/#{StoreParts}/g, partsContent);
        const filePath = path.join(
            this.outputPath,
            `abcx3_stores_library.dart`
        );
        await this.writeFile(filePath, content);
    }

    async generateDevtoolsSetupFile() {
        // Build feeds list from the generated stores
        const storeClassNames = Object.keys(this.dartStoreFiles)
            .sort() // stable, alphabetical
            .map(modelName => `${modelName}Store`);

        const feeds = storeClassNames
            .map((storeName) => `    StoreFeed(name: '${storeName}', items\$: ${storeName}.instance.items\$),`)
            .join('\n');

        const content = `import 'package:abcx3/gen_models/abcx3_stores_library.dart';\nimport 'package:abcx3_store_devtool/abcx3_store_devtool.dart';\nimport 'package:flutter/foundation.dart';\n\n/// Call from main() in debug builds to stream all store updates to DevTools\nvoid setupAbcx3StoresDevTool() {\n  if (!kDebugMode) return;\n\n  final feeds = <StoreFeed>[\n${feeds}\n  ];\n\n  Abcx3StoresDevtool.start(feeds);\n}\n`;

        // Place next to the generated libraries (output root)
        const filePath = path.join(this.outputPath, 'setup_stores_devtool.dart');
        await this.writeFile(filePath, content);
    }

    async generateEndpoints() {
        console.log('Generating endpoints...');
        const endpointGenerator = new EndpointGenerator();
        
        try {
            // Extract routes from the backend source code
            const backendPath = this.settings.backendPath || this.settings.BackendPath || './src';
            const routes = await endpointGenerator.extractRoutesFromBackend(backendPath);
            
            if (routes.length === 0) {
                console.log('No routes found in backend, skipping endpoint generation');
                return;
            }

            console.log(`Found ${routes.length} routes in backend`);
            
            // Generate the endpoints file
            const endpointsOutputPath = this.settings.endpointsOutputPath || this.settings.EndpointsOutputPath || 'gen_backend_routes.dart';
            const fullOutputPath = path.join(this.outputPath, endpointsOutputPath);
            
            endpointGenerator.createDartRoutesFile(routes, fullOutputPath, this.settings);
            
        } catch (error) {
            console.log('Error generating endpoints:', error);
        }
    }
}
