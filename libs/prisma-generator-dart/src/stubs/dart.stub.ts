export const dartBaseClassStub = `
#{AutoGeneratedWarningText}

import '../abcx3_common.library.dart';
#{AdditionalImports}

class #{ClassName}#{ParentClass} implements #{ImplementsPrismaModel} #{ImplementsId} {
    #{Properties}

    Set<String> $assignedFields = {};
    
    /// Creates a new instance of this class.
  /// All parameters are optional and default to null.
    #{ClassName}({#{ConstructorArgs}
      this.$assignedFields = const {},
    });

    #{UIDGetter}

    Map<String, GetPropertyValueFunction<#{Model}, dynamic>> propertyValueFunctionMap = {
      #{GetPropertyValueFunctions}
    };

    /// gets a function by property name that returns the property value from the model
    @override
  V? Function(#{Model}) getPropToValueFunction<V>(String propertyName) {
    final propFunction = propertyValueFunctionMap[propertyName];
    if (propFunction == null) {
      throw Exception('Property "$propertyName" not found in #{Model}');
    }
    return propFunction as V? Function(#{Model});
  }

    #{EqualById}

    /// Creates a new instance of this class from a JSON object.
    #{OverrideAnnotation}
    factory #{ClassName}.fromJson(JsonMap json) =>
      #{ClassName}(
        #{fromJsonArgs},
        $assignedFields: json.keys.toSet(),
      );

      /// Creates a new instance populated with the values of this instance and the given values,
    /// where the given values has precedence.
      #{OverrideAnnotation}  
    #{ClassName} copyWith({
        #{CopyWithArgs}
        }) {
        return #{ClassName}(
            #{CopyWithConstructorArgs}
        );
    }

    /// Creates a new instance populated with the values of this instance and the given instance,
    /// where the given instance's values has precedence.

    #{OverrideAnnotation}
    #{ClassName} copyWithInstanceValues(#{ClassName} #{InstanceName}) {
        return #{ClassName}(
            #{CopyWithInstanceConstructorArgs}
        );
    }

    /// Creates a new instance populated with the values of this instance and the given instance,
    /// where the given instance's values has precedence.
    /// Just like copyWithInstanceValues, but merges lists instead of replacing them.

    #{OverrideAnnotation}
    #{ClassName} mergeWithInstanceValues(#{ClassName} #{InstanceName}) {
        return #{ClassName}(
            #{MergeWithInstanceConstructorArgs}
        );
    }


    /// Updates this instance with the values of the given instance,
  /// where the given instance has precedence.

    #{OverrideAnnotation}
    #{ClassName} updateWithInstanceValues(#{ClassName} #{InstanceName}) {
        #{UpdateWithInstanceSetters}
        return this;
    }

    /// Converts this instance to a JSON object.
    /// 
    /// [serializedTypes] - Internal parameter tracking which model types have been serialized
    /// in the current chain to prevent circular references.
    /// [preventCircularSerialization] - When true (default), prevents infinite recursion by
    /// skipping relations whose types have already been serialized in the current chain.
    /// Set to false to serialize all relations (use with caution - may cause infinite loops).
    #{OverrideAnnotation}
    JsonMap toJson({
      Set<String>? serializedTypes,
      bool preventCircularSerialization = true,
    }) {
      final Set<String> serializedModels = preventCircularSerialization 
          ? {...?serializedTypes, '#{ClassName}'} 
          : const {};
      return {
        #{toJsonKeyValues}
      };
    }

      /// Determines whether this instance and another object represent the same
      /// instance.
    #{OverrideAnnotation}
    bool operator == (Object other) =>
            identical(this, other) || other is #{ClassName} &&
                runtimeType == other.runtimeType && $uid == other.$uid;

    /// Updates this instance with the values of the given instance,
    /// where this instance has precedence.
    #{OverrideAnnotation}
        int get hashCode => $uid.hashCode;
    }
    `;

    /* bool operator == (Object other) =>
      identical(this, other) || other is #{ClassName} &&
          runtimeType == other.runtimeType &&
          #{equalsKeyValues}; */

  // int get hashCode => #{hashCodeKeyValues};
  
export const dartUIDStub = `
#{OverrideAnnotation}
#{Type}#{Nullable} get $uid => #{PropName};`;

export const getPropertyValueFunctionStub = `"#{fieldName}": (m) => m.#{fieldName},`;

export const dartEqualByIdStub = `
#{OverrideAnnotation}
bool equalById(UID<#{Type}> other) => $uid == other.$uid;`

export const dartCopyWithArg = `Value<#{Type}#{Nullable}>? #{PropName}`;
export const dartCopyWithConstructorArg = `#{PropName}: #{PropName} != null ? #{PropName}.value : this.#{PropName}`;

export const dartCopyWithInstanceConstructorArg = `#{PropName}: #{InstanceName}.#{PropName} ?? #{PropName}`;
export const dartCopyWithInstanceConstructorListArg = `#{PropName}: #{InstanceName}.#{PropName}?.toSet().union(#{PropName}?.toSet() ?? {}).toList() ?? #{PropName}`;

export const dartMergeWithInstanceConstructorArg = `#{PropName}: #{InstanceName}.$assignedFields.contains('#{PropName}') ? #{InstanceName}.#{PropName} : #{PropName}`;
export const dartMergeWithInstanceModelListConstructorArg = `#{PropName}: (#{InstanceName}.$assignedFields.contains('#{PropName}') && #{InstanceName}.#{PropName} != null) ? mergeModelLists(#{PropName}, #{InstanceName}.#{PropName}) : #{PropName}`;

export const updateWithInstanceSetters = `if (#{InstanceName}.$assignedFields.contains('#{PropName}')) { #{PropName} = #{InstanceName}.#{PropName}; }`;
export const updateWithInstanceModelListSetters = `if (#{InstanceName}.$assignedFields.contains('#{PropName}') && #{InstanceName}.#{PropName} != null) { #{PropName} = mergeModelLists(#{PropName}, #{InstanceName}.#{PropName}); }`;

export const dartFromJsonArg = `#{PropName}: json['#{PropName}'] as #{Type}#{Nullable}`;
export const dartFromJsonIntArg = `#{PropName}: int.tryParse(json['#{PropName}'].toString())`;
export const dartFromJsonBigIntArg = `#{PropName}: json['#{PropName}'] != null ? BigInt.tryParse(json['#{PropName}'].toString()) : null`;
export const dartFromJsonRefArg = `#{PropName}: json['#{PropName}'] != null ? #{Type}.fromJson(json['#{PropName}'] as JsonMap) : null`;
export const dartFromJsonFloatArg = `#{PropName}: json['#{PropName}']?.toDouble()`;

export const dartFromJsonScalarIntListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}'] as List<dynamic>).map((e) => int.tryParse(e.toString())).toList() : null`;
export const dartFromJsonScalarBigIntListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}'] as List<dynamic>).map((e) => BigInt.tryParse(e.toString())).toList() : null`;
export const dartFromJsonScalarStringListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}'] as List<dynamic>).map((e) => e.toString()).toList() : null`;

// export const dartFromJsonModelListArg = `#{PropName}: json['#{PropName}'] != null ? createModels<#{Type}>(json['#{PropName}'], #{Type}.fromJson) : null`;
export const dartFromJsonModelListArg = `#{PropName}: json['#{PropName}'] != null ? createModels<#{Type}>((json['#{PropName}'] as List).cast<JsonMap>(), #{Type}.fromJson) : null`;

// export const dartFromJsonEnumArg = `#{PropName}: #{Type}.values.byName(json['#{PropName}'])`;
// export const dartFromJsonEnumListArg = `#{PropName}: (json['#{PropName}']).map((item) => #{Type}.values.byName(json[item])).toList())`;
export const dartFromJsonEnumArg = `#{PropName}: json['#{PropName}'] != null ? #{Type}.fromJson(json['#{PropName}']) : null`;
export const dartFromJsonEnumListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}']).map((item) => #{Type}.fromJson(item)).toList()) : null`;

export const dartFromJsonDateTimeArg = `#{PropName}: json['#{PropName}'] != null ? DateTime.parse(json['#{PropName}']) : null`;

export const toJsonPropertyStub = `if(#{PropName} != null) '#{PropName}': #{PropName}`;
export const toJsonBigIntPropertyStub = `if(#{PropName} != null) '#{PropName}': #{PropName}.toString()`;
export const toJsonObjectStub = `if(#{PropName} != null && (!preventCircularSerialization || !serializedModels.contains('#{Type}'))) '#{PropName}': #{PropName}#{Nullable}.toJson(serializedTypes: serializedModels, preventCircularSerialization: preventCircularSerialization)`;
export const toJsonObjectListStub = `if(#{PropName} != null && (!preventCircularSerialization || !serializedModels.contains('#{Type}'))) '#{PropName}': #{PropName}#{Nullable}.map((item) => item.toJson(serializedTypes: serializedModels, preventCircularSerialization: preventCircularSerialization)).toList()`;
export const toJsonDatePropertyStub = `if(#{PropName} != null) '#{PropName}': #{PropName}#{Nullable}.toIso8601String()`;

export const dartEqualStub = `#{PropName} == other.#{PropName}`;
export const dartListsEqualStub = `areListsEqual(#{PropName}, other.#{PropName})`;

export const dartHashCodeKeyValue = `#{PropName}.hashCode`;

export const dartConstructorArgument = `#{Required} this.#{PropName}`;
export const dartConstructorArgumentWithDefaultValue = `#{Required} this.#{PropName} = #{DefaultValue}`;

export const dartPropertyStub = `#{Type}#{Nullable} #{PropName};`;

export const dartPropertyStubWithDefaultValue = `#{Type}#{Nullable} #{PropName} = #{DefaultValue};`;

export const dartEnumStub = `
#{AutoGeneratedWarningText}
enum #{ModelName} {
    #{EnumValues};
   
    String toJson() => toString().split('.').last;

    factory #{ModelName}.fromJson(String name) => values.byName(name);
  
}
`;

// Enum-specific stubs (enums don't need circular reference prevention)
export const toJsonEnumStub = `if(#{PropName} != null) '#{PropName}': #{PropName}#{Nullable}.toJson()`;
export const toJsonEnumListStub = `if(#{PropName} != null) '#{PropName}': #{PropName}#{Nullable}.map((item) => item.toJson()).toList()`;
