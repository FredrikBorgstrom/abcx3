import { DMMF, generatorHandler, GeneratorOptions } from '@prisma/generator-helper';
import { convertBooleanStrings, convertEnvStrings, copyCommonSourceFiles, outputToConsoleAsync, writeFileSafelyAsync } from '@shared';
import { format } from 'prettier';
import { version } from './../package.json';
import { GENERATOR_NAME } from './constants';
import { ControllerGenerator } from './generators/controller.generator';
import { generateEnum } from './generators/enum.generator';
import { ModuleGenerator } from './generators/module.generator';
import { ServiceGenerator } from './generators/service.generator';
import { NameGenerator } from './nameGenerator';
import { NestGeneratorSettings } from './nest_settings.interface';

const defaultOptions: NestGeneratorSettings = {
    strict: false,
    dryRun: false,
    AutoGeneratedWarningText: '/*****    AUTO-GENERATED FILE - DO NOT MODIFY   *****/',
    prefix: 'gen',
    schemaPath: '',
    GenerateServices: true,
    GenerateEmptyControllersAndServices: false,
    GenerateControllers: false,
    GenerateModule: true,
    // InputExportPath: 'data/inputs',
    // InputSuffix: 'Input',
    // InputValidatorPackage: 'class-validator',
    // InputCreatePrefix: 'Create',
    // InputUpdatePrefix: 'Update',

    WrapWithNeverthrow: true,
    PrismaServiceImportPath: 'prisma/prisma.service',
    PrismaModuleName: 'PrismaModule',
    PrismaModuleImportPath: 'src/prisma/prisma.module',
    PrismaClientImportPath: '@prisma/client',

    EnumPath: 'enums'
};

generatorHandler({
    onManifest() {
        console.log(`${GENERATOR_NAME}:Registered`);
        return {
            version,
            defaultOutput: '../generated',
            prettyName: GENERATOR_NAME,
        };
    },
    onGenerate: async (options: GeneratorOptions) => {
        const configOverwrites = {
            schemaPath: options.schemaPath,
        };
        const optionsWithEnvSettings = convertEnvStrings(options.generator.config);
        const optionsWithBooleanSettings = convertBooleanStrings(optionsWithEnvSettings);
        const settings: NestGeneratorSettings = {
            ...defaultOptions,
            ...optionsWithBooleanSettings,
            ...configOverwrites,
        };

        const mainGenerator = new MainGenerator(options, settings);
        await mainGenerator.generateFiles();
    }
});

class MainGenerator {

    private writeFile: (path: string, content: string) => Promise<void>;
    private nameGenerator: NameGenerator;

    constructor(private options: GeneratorOptions, private settings: NestGeneratorSettings) {
        this.writeFile = settings?.dryRun ?
            async (path, content) => await outputToConsoleAsync(path, await this.formatContent(path, content)) :
            async (path, content) => await writeFileSafelyAsync(path, await this.formatContent(path, content));
        this.nameGenerator = NameGenerator.singleton;
        this.nameGenerator.prefix = settings.prefix ?? '';
        this.nameGenerator.basePath = options.generator.output?.value || 'gen';
    }

    formatContent(filePath: string, content: string): Promise<string> {
        if (filePath.match(/.ts$/)) {
            return format(content, { useTabs: true, tabWidth: 4, parser: 'typescript' });
        } else {
            return Promise.resolve(content);
        }
    }


    async generateFiles() {
        await copyCommonSourceFiles('ts_source', this.nameGenerator.basePath);
        await this.generateFilesForAllModels();
        if (this.settings?.secondaryOutputPath) {
            this.nameGenerator.prefix = '';
            this.nameGenerator.basePath = this.settings.secondaryOutputPath;
            this.settings.AutoGeneratedWarningText = '';
            await this.generateFilesForAllModels();
        }
    }

    async generateFilesForAllModels() {
        for (const model of this.options.dmmf.datamodel.models) {
            if (this.settings?.GenerateServices) await this.generateServiceFile(model);
            //if (this.settings.GenerateInputs)  await this.generateInputFile(model);
            if (this.settings.GenerateControllers) await this.generateControllerFile(model);
            if (this.settings.GenerateModule) await this.generateModuleFile(model);
        }
    }


    async generateEnumFile(tEnum: DMMF.DatamodelEnum) {
        let content = generateEnum(tEnum, this.settings);
        let filePath = this.nameGenerator.geFilePath(tEnum, 'enum');
        await this.writeFile(filePath, content);
    }

    /* async generateInputFile(model: DMMF.Model) {
        const inputGenerator = new InputGenerator(this.settings, model);
        const inputContent = await inputGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'controller')
        await this.writeFile(filePath, inputContent);
    } */

    async generateServiceFile(model: DMMF.Model) {
        console.log(` > Generating Service for Model ${model.name}`);
        const serviceGenerator = new ServiceGenerator(this.settings, model);
        const crudServiceContent = await serviceGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'service');
        await this.writeFile(filePath, crudServiceContent);
    }

    async generateControllerFile(model: DMMF.Model) {
        const controllerGenerator = new ControllerGenerator(this.settings, model);
        const controllerContent = await controllerGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'controller');
        await this.writeFile(filePath, controllerContent);
    }

    async generateModuleFile(model: DMMF.Model) {
        const moduleGenerator = new ModuleGenerator(model, this.settings);
        const content = moduleGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'module');
        await this.writeFile(filePath, content);
    }
}

