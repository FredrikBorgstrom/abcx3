import { DMMF, generatorHandler, GeneratorOptions } from '@prisma/generator-helper';
import { convertBooleanStrings, convertEnvStrings, copyCommonSourceFiles, outputToConsoleAsync, writeFileSafelyAsync } from '@shared';
import { getDMMF } from '@prisma/internals';
import { format } from 'prettier';
import { version } from './../package.json';
import { GENERATOR_NAME } from './constants';
import { ControllerGenerator } from './generators/controller.generator';
import { generateEnum } from './generators/enum.generator';
import { ModuleGenerator } from './generators/module.generator';
import { ServiceGenerator } from './generators/service.generator';
import { NameGenerator } from './nameGenerator';
import { NestGeneratorSettings } from './nest_settings.interface';

const defaultOptions: NestGeneratorSettings = {
    strict: false,
    dryRun: false,
    AutoGeneratedWarningText: '/*****    AUTO-GENERATED FILE - DO NOT MODIFY   *****/',
    prefix: 'gen',
    schemaPath: '',
    GenerateServices: true,
    GenerateEmptyControllersAndServices: false,
    GenerateControllers: false,
    GenerateModule: true,
    // InputExportPath: 'data/inputs',
    // InputSuffix: 'Input',
    // InputValidatorPackage: 'class-validator',
    // InputCreatePrefix: 'Create',
    // InputUpdatePrefix: 'Update',

    WrapWithNeverthrow: true,
    PrismaServiceImportPath: 'prisma/prisma.service',
    PrismaModuleName: 'PrismaModule',
    PrismaModuleImportPath: 'src/prisma/prisma.module',
    PrismaClientImportPath: '@prisma/client',
    addJSExtensionToImports: false,
    EnumPath: 'enums'
};

generatorHandler({
    onManifest() {
        console.log(`${GENERATOR_NAME}:Registered`);
        return {
            version,
            defaultOutput: '../generated',
            prettyName: GENERATOR_NAME,
        };
    },
    onGenerate: async (options: GeneratorOptions) => {
        const configOverwrites = {
            schemaPath: options.schemaPath,
        };
        const optionsWithEnvSettings = convertEnvStrings(options.generator.config);
        const optionsWithBooleanSettings = convertBooleanStrings(optionsWithEnvSettings);
        const settings: NestGeneratorSettings = {
            ...defaultOptions,
            ...optionsWithBooleanSettings,
            ...configOverwrites,
        };

        const mainGenerator = new MainGenerator(options, settings);
        await mainGenerator.generateFiles();
    }
});

class MainGenerator {

    private writeFile: (path: string, content: string) => Promise<void>;
    private nameGenerator: NameGenerator;

    constructor(private options: GeneratorOptions, private settings: NestGeneratorSettings) {
        this.writeFile = settings?.dryRun ?
            async (path, content) => await outputToConsoleAsync(path, await this.formatContent(path, content)) :
            async (path, content) => await writeFileSafelyAsync(path, await this.formatContent(path, content));
        this.nameGenerator = NameGenerator.singleton;
        this.nameGenerator.prefix = settings.prefix ?? '';
        this.nameGenerator.basePath = options.generator.output?.value || 'gen';
    }

    formatContent(filePath: string, content: string): Promise<string> {
        if (filePath.match(/.ts$/)) {
            return format(content, { useTabs: true, tabWidth: 4, parser: 'typescript' });
        } else {
            return Promise.resolve(content);
        }
    }


    async generateFiles() {
        await copyCommonSourceFiles('ts_source', this.nameGenerator.basePath);
        await this.generateFilesForAllModels();
        if (this.settings?.secondaryOutputPath) {
            this.nameGenerator.prefix = '';
            this.nameGenerator.basePath = this.settings.secondaryOutputPath;
            this.settings.AutoGeneratedWarningText = '';
            await this.generateFilesForAllModels();
        }
    }

    async generateFilesForAllModels() {
        // Prisma 7: Parse schema string if options.datamodel is a string
        let models = this.options.dmmf?.datamodel?.models || [];
        let enums = this.options.dmmf?.datamodel?.enums || [];
        
        if (models.length === 0 && typeof (this.options as any)?.datamodel === 'string') {
            try {
                let schemaString = (this.options as any).datamodel;
                
                // Prisma 7: If schemaPath points to a directory, read all .prisma files
                const schemaPath = this.options.schemaPath || (this.options as any).schemaPath;
                if (schemaPath && require('fs').existsSync(schemaPath)) {
                    const stat = require('fs').statSync(schemaPath);
                    if (stat.isDirectory()) {
                        // Read all .prisma files in the directory and combine them
                        const files = require('fs').readdirSync(schemaPath)
                            .filter((f: string) => f.endsWith('.prisma'))
                            .sort(); // Sort for consistent ordering
                        
                        schemaString = files
                            .map((f: string) => require('fs').readFileSync(require('path').join(schemaPath, f), 'utf8'))
                            .join('\n\n');
                        
                        console.log(`Combined ${files.length} schema files from directory`);
                    } else if (stat.isFile() && schemaPath.endsWith('.prisma')) {
                        // Single file - use it directly
                        schemaString = require('fs').readFileSync(schemaPath, 'utf8');
                    }
                }
                
                const parsedDmmf = await getDMMF({ datamodel: schemaString });
                // Store in options for PrismaHelper access
                (this.options as any).parsedDmmf = parsedDmmf;
                models = parsedDmmf?.datamodel?.models || [];
                enums = parsedDmmf?.datamodel?.enums || [];
                console.log(`Parsed schema string: found ${models.length} models, ${enums.length} enums`);
            } catch (error) {
                console.warn('Failed to parse schema string:', error);
            }
        }
        for (const model of models) {
            if (this.settings?.GenerateServices) await this.generateServiceFile(model);
            //if (this.settings.GenerateInputs)  await this.generateInputFile(model);
            if (this.settings.GenerateControllers) await this.generateControllerFile(model);
            if (this.settings.GenerateModule) await this.generateModuleFile(model);
        }
    }


    async generateEnumFile(tEnum: DMMF.DatamodelEnum) {
        let content = generateEnum(tEnum, this.settings);
        let filePath = this.nameGenerator.geFilePath(tEnum, 'enum');
        await this.writeFile(filePath, content);
    }

    /* async generateInputFile(model: DMMF.Model) {
        const inputGenerator = new InputGenerator(this.settings, model);
        const inputContent = await inputGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'controller')
        await this.writeFile(filePath, inputContent);
    } */

    async generateServiceFile(model: DMMF.Model) {
        console.log(` > Generating Service for Model ${model.name}`);
        const serviceGenerator = new ServiceGenerator(this.settings, model);
        const crudServiceContent = await serviceGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'service');
        await this.writeFile(filePath, crudServiceContent);
    }

    async generateControllerFile(model: DMMF.Model) {
        const controllerGenerator = new ControllerGenerator(this.settings, model);
        const controllerContent = await controllerGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'controller');
        await this.writeFile(filePath, controllerContent);
    }

    async generateModuleFile(model: DMMF.Model) {
        const moduleGenerator = new ModuleGenerator(model, this.settings);
        const content = moduleGenerator.generateContent();
        const filePath = this.nameGenerator.geFilePath(model, 'module');
        await this.writeFile(filePath, content);
    }
}

