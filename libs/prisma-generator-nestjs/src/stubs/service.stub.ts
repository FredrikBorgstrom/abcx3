export const ServiceStub = `
#{AutoGeneratedWarningText}

import {
    Injectable,
    InternalServerErrorException,
    NotFoundException,
} from '@nestjs/common';
import { Prisma, #{Model} #{RelatedFieldTypesImport} } from '#{PrismaClientImportPath}';
import {
    PrismaService,
} from '#{PrismaServiceImportPath}';
import { WithLogicalOperators, WithoutLogicalOperators, getByFieldValuesHelper, getManyByFieldValuesHelper } from '../store_common';
#{NeverthrowImport}

@Injectable()
export class #{ServiceClassName}<T extends #{Model} = #{Model}, I extends Prisma.#{Model}WhereInput = Prisma.#{Model}WhereInput> {
    constructor(protected readonly prismaService: PrismaService) {}

    async getAll(
		modelFilter?: WithLogicalOperators<I>,
	): Promise<T[] | Error> {
		return getManyByFieldValuesHelper<T, I>(
			this.prismaService.#{moDel}.findMany,
			null,
			modelFilter,
		);
    }

        async getByFieldValues(
            fieldsAndValues: WithoutLogicalOperators<I>,
            modelFilter?: WithLogicalOperators<I>,
        ): Promise<T | Error> {
            return getByFieldValuesHelper<T, I>(
                this.prismaService.#{moDel}.findFirst,
                fieldsAndValues,
                modelFilter,
            );
        }
    
        async getManyByFieldValues(
            fieldsAndValues: WithoutLogicalOperators<I>,
            modelFilter?: WithLogicalOperators<I>,
        ): Promise<T[] | Error> {
            return getManyByFieldValuesHelper<T, I>(
                this.prismaService.#{moDel}.findMany,
                fieldsAndValues,
                modelFilter,
            );
        }

    
    // get by id methods

    #{byIdMethods}

    // relation fields methods

    #{relationFieldMethods}

}
`;
export const ServiceEmptyStub = `
#{AutoGeneratedWarningText}

import { Injectable } from '@nestjs/common';
import { PrismaService } from '#{PrismaServiceImportPath}';

@Injectable()
export class #{ServiceClassName} {
    constructor(protected readonly prismaService: PrismaService) {}

}
`;

export const NeverthrowImport = `import { err, ok, Result } from 'neverthrow';`;

export const crudRelationFieldStub = `
async get#{RelationFieldNameCapitalized}(where: Prisma.#{Model}WhereUniqueInput): Promise<#{RelationMethodReturnType} | Error> {
    try {
        const result = await this.prismaService.#{moDel}.findUnique({
            where,
            include: { #{RelationFieldName} : true },
        });
        return result.#{RelationFieldName};
    } catch (e) {
        throw new InternalServerErrorException(\`Could not get #{RelationFieldName} for #{Model}\`);
    }
}
`;

export const idMethods_neverThrow = `
async getById(#{idName}: #{idType}): Promise<#{Model} | Error> {
    try {
    const result = await this.prismaService.#{moDel}.findUniqueOrThrow({
        where: { #{idName} }
    });
    return result;
    } catch(e) {
        throw new NotFoundException(\`#{Model} Resource \${id} was not found\`);
    }
}

async updateById(#{idName}: #{idType}, data: Prisma.#{Model}UpdateInput): Promise<#{Model} | Error> {
    try {
        const result = await this.prismaService.#{moDel}.update({
            where: { #{idName} },
            data: data,
        });
        return result;
    } catch (e) {
        throw new InternalServerErrorException(\`Could not update #{Model} Resource \${#{idName}}\`);
    }
}

async deleteById(#{idName}: #{idType}): Promise<#{Model} | Error> {
    try {
        const result = await this.prismaService.#{moDel}.delete({ where: { #{idName} } });
        return result;
    } catch (e) {
        throw new InternalServerErrorException(\`Could not delete #{Model} Resource \${#{idName}}\`);
    }
}
`;

